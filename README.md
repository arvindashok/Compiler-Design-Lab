## Compiler Design Lab Report

### Submitted by:
**Name:** Arvind Ashok  
**Roll Number:** 1BM21CS032

### Under the Guidance of:
**Professor:** Prof. Sunayana S  
**Department:** Computer Science and Engineering  
**Institution:** B.M.S. College of Engineering, Bengaluru

---

### Table of Contents

1. **Lab 1: Lexical Analysis**
   - Program 1.1: Recognizing Different Tokens
   - Program 1.2: Identifying Alphabets and Numbers
   - Program 1.3: Identifying Vowels and Consonants
2. **Lab 2: More Lexical Analysis**
   - Program 2.1: Counting Words in a Sentence
   - Program 2.2: Demonstrating Regular Definitions
   - Program 2.3: Identifying Tokens in a Program (Input from File, Output to Terminal)
   - Program 2.4: Identifying Tokens in a Program (Input from File, Output to Another File)
   - Program 2.5: Finding the Length of an Input String
3. **Lab 3: Advanced Lexical Analysis**
   - Program 3.1: Recognizing Floating Point Numbers
   - Program 3.2: Determining Compound or Simple Sentences
   - Program 3.3: Checking if a Sentence Ends with Punctuation Marks
   - Program 3.4: Checking if a Sentence Begins with English Articles
   - Program 3.5: Counting Comment Lines in a Program
   - Program 3.6: Checking if a User-Entered Number is Signed or Unsigned
4. **Lab 4: File Manipulation with Lex**
   - Program 4.1: Copying a File with Space Compression
   - Program 4.2: Recognizing Various Tokens
5. **Lab 5: Lexical Analysis in C**
   - Program 5.1: Recognizing Keywords, Identifiers, Numbers, Operators, and Punctuations
6. **Lab 6: Recursive Descent Parsing**
   - Program 6.1: Parsing Grammar Rules
7. **Lab 7: Syntax Analysis with YACC**
   - Program 7.1: Designing Grammar for Arithmetic Expressions
   - Program 7.2: Recognizing Specific Strings
   - Program 7.3: Generating Syntax Tree for Arithmetic Expressions
   - Program 7.4: Converting Infix to Postfix Expression
8. **Lab 8: Intermediate Code Generation**
   - Program 8.1: Generating Three Address Code for Expressions
9. **Lab 9: Advanced YACC Programming**
   - Program 9.1: Generating Three Address Code for an Expression

---

### Lab 1: Lexical Analysis

#### Program 1.1: Recognizing Different Tokens
- This program recognizes keywords, identifiers, constants, operators, and punctuation symbols in an input program.

#### Program 1.2: Identifying Alphabets and Numbers
- This program identifies alphabets as characters and numbers as digits in a string.

#### Program 1.3: Identifying Vowels and Consonants
- This program identifies vowels and consonants in a string.

### Lab 2: More Lexical Analysis

#### Program 2.1: Counting Words in a Sentence
- This program counts the number of words in a sentence.

#### Program 2.2: Demonstrating Regular Definitions
- This program demonstrates the use of regular definitions.

#### Program 2.3: Identifying Tokens in a Program (Input from File, Output to Terminal)
- This program identifies tokens in a program by taking input from a file and printing the output on the terminal.

#### Program 2.4: Identifying Tokens in a Program (Input from File, Output in Another File)
- This program identifies tokens in a program by taking input from a file and printing the output in another file.

#### Program 2.5: Finding the Length of an Input String
- This program finds the length of the input string.

### Lab 3: Advanced Lexical Analysis

#### Program 3.1: Recognizing Floating Point Numbers
- This program recognizes floating point numbers.

#### Program 3.2: Determining Compound or Simple Sentences
- This program checks if a sentence is compound or simple based on specific words.

#### Program 3.3: Checking if a Sentence Ends with Punctuation Marks
- This program checks if a sentence ends with specific punctuation marks.

#### Program 3.4: Checking if a Sentence Begins with English Articles
- This program checks if a sentence begins with English articles.

#### Program 3.5: Counting Comment Lines in a Program
- This program counts the number of comment lines in a program.

#### Program 3.6: Checking if a User-Entered Number is Signed or Unsigned
- This program checks if a user-entered number is signed or unsigned.

### Lab 4: File Manipulation with Lex

#### Program 4.1: Copying a

 File with Space Compression
- This program copies a file with space compression.

#### Program 4.2: Recognizing Various Tokens
- This program recognizes various tokens in a program.

### Lab 5: Lexical Analysis in C

#### Program 5.1: Recognizing Keywords, Identifiers, Numbers, Operators, and Punctuations
- This program recognizes keywords, identifiers, numbers, operators, and punctuations in a C program.

### Lab 6: Recursive Descent Parsing

#### Program 6.1: Parsing Grammar Rules
- This program parses grammar rules.

### Lab 7: Syntax Analysis with YACC

#### Program 7.1: Designing Grammar for Arithmetic Expressions
- This program designs grammar for arithmetic expressions.

#### Program 7.2: Recognizing Specific Strings
- This program recognizes specific strings.

#### Program 7.3: Generating Syntax Tree for Arithmetic Expressions
- This program generates a syntax tree for arithmetic expressions.

#### Program 7.4: Converting Infix to Postfix Expression
- This program converts an infix expression to postfix expression.

### Lab 8: Intermediate Code Generation

#### Program 8.1: Generating Three Address Code for Expressions
- This program generates three-address code for expressions.

### Lab 9: Advanced YACC Programming

#### Program 9.1: Generating Three Address Code for an Expression
- This program generates three-address code for an expression.

---

### Conclusion

In this series of lab experiments, we explored various aspects of compiler design, focusing on lexical analysis, syntax analysis, and intermediate code generation. These experiments provided valuable insights into the workings of lexical analyzers, parsers, and code generators. We gained hands-on experience in designing grammars, recognizing tokens, and generating intermediate representations of source code. Overall, these labs enhanced our understanding of compiler construction principles and equipped us with practical skills essential for software development and language design.
